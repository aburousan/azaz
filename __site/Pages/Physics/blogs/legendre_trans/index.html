<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.16.4 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
   <link rel="stylesheet" href="/libs/katex/katex.min.css">
     
   <link rel="stylesheet" href="/libs/highlight/styles/github.min.css">
   
  <link rel="stylesheet" href="/css/franklin.css">
<link rel="stylesheet" href="/css/minimal-mistakes.css">
<link rel="stylesheet" href="/css/adjust.css">
<link rel="icon" href="/assets/favicon.jpg">
<!--[if IE ]>
<style>
  /* old IE unsupported flexbox fixes */
  .greedy-nav .site-title {
    padding-right: 3em;
  }
  .greedy-nav button {
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
  }
</style>
<![endif]-->

   <title>Legendre's Tranformation: A intuitive approach</title>  
  <!-- end custom head snippets -->
</head>
<body class="layout--single">
  <div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        <a class="site-title" href="/">Azazaya</a>
        <ul class="visible-links">
          <li class="masthead__menu-item"><a href="/home_page/" >Home</a></li>
          <li class="masthead__menu-item"><a href="/Pages/Maths/Maths_Home/" >Maths Home</a></li>
          <li class="masthead__menu-item"><a href="/Pages/Physics/Physics_Home/" >Physics Home</a></li>
          <li class="masthead__menu-item"><a href="/Pages/Tags_page">Tags</a></li>
        </ul>
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>

  <div class="initial-content">
    <div id="main" role="main">
      <div class="sidebar sticky">
        <div itemscope itemtype="https://schema.org/Person">
          <div class="author__avatar">
            <img src="/assets/minimal-mistakes/Rousan.jpeg" alt="Septimia Zenobia" itemprop="image">
          </div>
          <div class="author__content">
            <h3 class="author__name" itemprop="name">Kazi Abu Rousan</h3>
            <p class="author__bio" itemprop="description">Just some random dude.</p>
          </div>
          <div class="author__urls-wrapper">
            <button class="btn btn--inverse">Follow</button>
            <ul class="author__urls social-icons">
              <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
                <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Murshidabad, India</span></li>
                <li><a href="https://www.instagram.com/azavzya/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-instagram" aria-hidden="true"></i> Instagram</a></li>
              <li><a href="https://www.linkedin.com/in/kazi-abu-rousan-819848198/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
            </ul>
          </div>
        </div>
      </div>

<!-- Content appended here -->


  <script src="/libs/plotly/plotly.min.js"></script> 
  <script>
    // This function is used when calling `\fig{...}` See # Using \fig{...} below
    const PlotlyJS_json = async (div, url) => {
      response = await fetch(url); // get file
      fig = await response.json(); // convert it to json
      // Make the plot fit the screen responsively. See the documentation of plotly.js. https://plotly.com/javascript/responsive-fluid-layout/
      if (typeof fig.config === 'undefined') { fig["config"]={} }
      delete fig.layout.width
      delete fig.layout.height
      fig["layout"]["autosize"] = true
      fig["config"]["autosizable"] = true
      fig["config"]["responsive"] = true

      // make it easier to scroll throught the website rather than being blocked by a figure.
      fig.config["scrollZoom"] = false

      // PlotlyJS.savefig by default add the some more attribute to make a static plot.
      // Disable them to make the website fancier.
      delete fig.config.staticPlot
      delete fig.config.displayModeBar
      delete fig.config.doubleClick
      delete fig.config.showTips

      Plotly.newPlot(div, fig);
    };
  </script>
  


  <script src="/libs/clipboard.min.js"></script><div class="franklin-content">
<div class="franklin-toc"><ol><li><a href="#introduction">Introduction</a><ol><li><a href="#transformaing_one_function_into_another_without_infgormation_lost">Transformaing one function into another without infgormation lost</a></li><li><a href="#finding_the_lost_information">Finding the lost information</a></li></ol></li><li><a href="#legendre_transformation">Legendre Transformation</a><ol><li><a href="#introduction__2">Introduction</a></li><li><a href="#what_functions_respect_legendre_transformation">What functions respect legendre transformation?</a></li><li><a href="#legendre_transform_of_multi-variable_functions">Legendre Transform of multi-variable functions</a></li></ol></li><li><a href="#application_of_legendre_transform">Application of Legendre Transform</a></li></ol></div>
<h1 id="legendres_tranformation_an_intuitive_approach"><a href="#legendres_tranformation_an_intuitive_approach" class="header-anchor">Legendre&#39;s Tranformation: An Intuitive Approach</a></h1>
<p><strong><span style="color: purple">Legendre Transformation</span></strong> is an involutive transformation on real-valued functions that are convex on a real variable. Specifically, if a real-valued multivariable function is convex on one of its independent real variables, then the Legendre transform with respect to this variable is applicable to the function.</p>
<p>This uses the fact that <strong><span style="color: blue">points and lines are related by some sort of duality</span></strong>, which let&#39;s us relate different ideas of physics to each other. Although, we learn it just as a transformation in Classical Mechanics &amp; Thermodynamics, it is really simple and intuitive. </p>
<p>In this blog, we will undertand exactly that.<br/></p>

  <fieldset class=" poem"><legend class=" poem-legend"> ü™∂ Poem</legend>
      <strong>A curve of thought, so smooth, so sly,<br/> Hides truth in tangents passing by.<br/> Each slope a whisper, each line a clue,<br/> Trade x for p ‚Äî the world feels new.<br/> In mirrors of math, two forms agree,<br/> Lagrange and Hamilton ‚Äî duality‚Äôs key.<br/> Where physics and geometry softly rhyme,<br/> Lives the Legendre‚Äôs timeless design..</strong><br/></p>
<p>                                  ---K.A.Rousan</p>
<p>
  </fieldset>
  
<h2 id="introduction"><a href="#introduction" class="header-anchor">Introduction</a></h2>
<p>Suppose we have some function \(y=f(x)\). We can draw it as some curve on x-y plane. So, all the information of the function is stored in that graph. But as It can be seen below if we just draw all the tangent lines of the graph, we can get the curve itself, i.e., <strong><span style="color: blue">All the information of the curve is stored in it&#39;s tangent lines</span></strong>. To be more precise <strong><span style="color: red">y intercepts of it&#39;s tangent lines</span></strong>&#40;but not for all type of functions&#41;. 
<!-- Load JSXGraph + MathJax -->
<script type="text/javascript" charset="UTF-8"
 src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
<link rel="stylesheet"
 type="text/css" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />
<script id="MathJax-script" async
 src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Container -->
<div style="text-align:center; margin-bottom:10px;">
  <label for="funcSelect"><b>Select a function:</b></label>
  <select id="funcSelect" style="font-size:1rem; padding:4px;">
    <option value="x*x">f(x) = x¬≤</option>
    <option value="x*x*x*x">f(x) = x‚Å¥</option>
    <option value="Math.exp(-x)">f(x) = exp(-x)</option>
    <option value="Math.exp(x)">f(x) = exp(x)</option>
  </select>
</div>

<div id="board" class="jxgbox" style="width:500px; height:500px; margin:auto; border:2px solid #aaa;"></div>

<script>
  JXG.Options.text.useMathJax = true;

  // Initialize JSXGraph board
  var board = JXG.JSXGraph.initBoard("board", {
    boundingbox: [-5, 10, 5, -5],
    axis: true,
    showCopyright: false,
    showNavigation: false
  });

  let mainCurve = null;
  let tangents = [];

  // Function to draw selected function and its tangents
  function drawFunction(funcStr) {
    // Clear previous drawings
    if (mainCurve) board.removeObject(mainCurve);
    tangents.forEach(t => board.removeObject(t));
    tangents = [];

    // Create the function f(x)
    const f = (x) => eval(funcStr);

    // Plot the main curve
    mainCurve = board.create('functiongraph', [f, -4, 4], {
      strokeWidth: 2,
      strokeColor: '#0047AB'
    });

    // Plot tangent lines at many x-values
    const N = 40;
    const dx = 0.001;
    for (let i = 0; i <= N; i++) {
      const x0 = -4 + (8 * i) / N;
      const y0 = f(x0);
      const slope = (f(x0 + dx) - f(x0 - dx)) / (2 * dx); // numerical derivative
      const tangent = (x) => slope * (x - x0) + y0;
      const t = board.create('functiongraph', [tangent, -5, 5], {
        strokeColor: '#bd0a0aff',
        strokeWidth: 1,
        opacity: 0.5
      });
      tangents.push(t);
    }
  }

  // Draw initial function
  drawFunction("x*x");

  // Update when the dropdown changes
  document.getElementById("funcSelect").addEventListener("change", function() {
    drawFunction(this.value);
  });
</script>
</p>
<h3 id="transformaing_one_function_into_another_without_infgormation_lost"><a href="#transformaing_one_function_into_another_without_infgormation_lost" class="header-anchor">Transformaing one function into another without infgormation lost</a></h3>
<p>To go further, let&#39;s start with the function:</p>
\[
f(x) = x^2
\]
<p>What kind of information is present here? The answer is for any value \(x\) on the real number we have a value \(f(x)=x^2\). Our goal is to transform \(f\) from depending on \(x\) to a new function \(g\) such that it depends on \(p\). But the catch is: <strong><span style="color: purple">we don&#39;t want to loose any information in the process</span></strong>. </p>
<p>This is done through derivative. If we take the derivative of \(f(x)\), we get,</p>
\[
p(x) = \frac{df}{dx} = 2x
\]

<!-- Load JSXGraph -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraphcore.js"></script>
<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/jsxgraph/distrib/jsxgraph.css" />

<div id="tangentBoard" class="jxgbox" style="width:550px; height:500px; margin:auto; border:2px solid #aaa;"></div>

<script>
  JXG.Options.text.useMathJax = true;

  var board = JXG.JSXGraph.initBoard('tangentBoard', {
    boundingbox: [-5, 10, 5, -5],
    axis: true,
    showCopyright: false,
    showNavigation: false
  });

  // --- Function f(x) = x^2 ---
  const f = x => x * x;
  const df = x => 2 * x;

  // --- Plot f(x) ---
  const curve = board.create('functiongraph', [f, -4, 4],
    { strokeColor: '#0047AB', strokeWidth: 2 });

  // --- Slider for x0 ---
  const slider = board.create('slider', [[-4.5, 9], [4.5, 9], [-4, 0, 4]],
    { name: 'x‚ÇÄ', snapWidth: 0.1 });

  // --- Movable point P(x0, f(x0)) ---
  const P = board.create('point', [
    () => slider.Value(),
    () => f(slider.Value())
  ], {
    name: 'P',
    size: 3,
    color: '#D13F32',
    fixed: true
  });

  // --- Tangent line at P ---
  const tangent = board.create('line', [
    () => [slider.Value(), f(slider.Value())],
    () => [slider.Value() + 1, f(slider.Value()) + df(slider.Value())]
  ], {
    strokeColor: '#1CA9C9',
    strokeWidth: 2
  });

  // --- Y-intercept (0, b) ---
  const intercept = board.create('point', [
    0,
    () => f(slider.Value()) - df(slider.Value()) * slider.Value()
  ], {
    name: () => {
      let x0 = slider.Value();
      let b = f(x0) - df(x0) * x0;
      return `(0, ${b.toFixed(2)})`;
    },
    color: '#E65C00',
    size: 2,
    label: { offset: [10, -10] }
  });

  // --- Trail of previous tangents ---
  let tangentTrail = [];
  const maxTrail = 20;

  slider.on('drag', function() {
    const x0 = slider.Value();
    const y0 = f(x0);
    const slope = df(x0);
    const b = y0 - slope * x0;

    // Create faint tangent for the trail
    const t = board.create('functiongraph', [
      x => slope * x + b, -5, 5
    ], {
      strokeColor: '#1CA9C9',
      strokeWidth: 1,
      opacity: 0.25,
      fixed: true
    });

    tangentTrail.push(t);
    if (tangentTrail.length > maxTrail) {
      board.removeObject(tangentTrail.shift());
    }

    board.update();
  });
</script>

<p>So, \(p\) gives the slope of the tangent line at every \(x\). In this specific example, for every value of \(x\) we get a specific value of \(p\), i.e., <strong><span style="color: blue">there is a 1 to 1 corresondance between \(x\) and \(p\)</span></strong>. This allows us to to consider another function \(x(p)\), i.e.,</p>
\[
x(p) = \frac{p}{2}
\]
<p>Hence, we have two ways of understanding:</p>
<ol>
<li><p>Either \(p\) as a function of \(x\).</p>
</li>
<li><p>Or \(x\) as a function of \(p\).</p>
</li>
</ol>
<p>We can then plug \(x\) as a function of \(p\) directly into \(f\), making it now function of \(p\). This gives us:</p>
\[
f(x(p)) = \frac{p^2}{4} = g(p)
\]
<p>It seems we have suceed in transforming \(f\) from a function that depends on \(x\) to a new function that depends on \(p\) without lossing any information. But sadly it&#39;s not that simple.</p>
<h3 id="finding_the_lost_information"><a href="#finding_the_lost_information" class="header-anchor">Finding the lost information</a></h3>
<p>To understand this now consider,</p>
\[
f(x) = (x-d)^2
\]
<p>In this case \(dy/dx = 2(x-d) = p\). If we plug it back, we get,</p>
\[
f(p) = \frac{p^2}{4}
\]
<p>again&#33; So, <strong><span style="color: red">whatever value we choose for \(d\)</span></strong>, we will get the same end function. <strong><span style="color: blue">The information about \(d\) is lost in the procedure we are currently following</span></strong>. The reason it happens is very simple. This happens because we have only been considering the tangent lines of each function which turns out to be the same everywhere just shifted. 
<div style="text-align:center; margin-bottom:6px;">
  <label><b>Branch:</b></label>
  <select id="branchSelect" style="font-size:1rem; padding:4px;">
    <option value="1">Right branch (+‚àöy)</option>
    <option value="-1">Left branch (‚àí‚àöy)</option>
  </select>
</div>

<div id="fullParabolaBoard" class="jxgbox"
     style="width:650px;height:500px;margin:auto;border:2px solid #aaa;"></div>

<script>
(function() {
  const brd = JXG.JSXGraph.initBoard('fullParabolaBoard', {
    boundingbox: [-6, 20, 10, -6],
    axis: true,
    showNavigation: false,
    showCopyright: false
  });

  // Functions
  const f1 = x => x*x;
  const f2 = x => (x-4)*(x-4);
  const df1 = x => 2*x;
  const df2 = x => 2*(x-4);

  // Draw both parabolas
  brd.create('functiongraph', [f1, -5, 9],
    { strokeColor: '#0047AB', strokeWidth: 2 });
  brd.create('functiongraph', [f2, -1, 9],
    { strokeColor: '#178F3E', strokeWidth: 2 });

  // Slider for HEIGHT
  const s = brd.create('slider', [[-5,18],[8,18],[0,4,16]],
    { name:'y‚ÇÄ', snapWidth:0.1 });

  // Get branch sign from dropdown
  let branch = 1; // +‚àöy default
  document.getElementById("branchSelect").addEventListener("change", e => {
    branch = parseInt(e.target.value);
    brd.update();
  });

  // Points at same height (left or right branch)
  const P1 = brd.create('point', [
    ()=>branch * Math.sqrt(s.Value()),
    ()=>s.Value()
  ], { name:'P‚ÇÅ', color:'#D13F32', size:3, fixed:true });

  const P2 = brd.create('point', [
    ()=>4 + branch * Math.sqrt(s.Value()),
    ()=>s.Value()
  ], { name:'P‚ÇÇ', color:'#E6B800', size:3, fixed:true });

  // Tangents at those points
  const T1 = brd.create('line', [
    ()=>[branch * Math.sqrt(s.Value()), s.Value()],
    ()=>[branch * Math.sqrt(s.Value()) + 1,
         s.Value() + df1(branch * Math.sqrt(s.Value()))]
  ], { strokeColor:'#1CA9C9', strokeWidth:2 });

  const T2 = brd.create('line', [
    ()=>[4 + branch * Math.sqrt(s.Value()), s.Value()],
    ()=>[4 + branch * Math.sqrt(s.Value()) + 1,
         s.Value() + df2(4 + branch * Math.sqrt(s.Value()))]
  ], { strokeColor:'#7FD16C', strokeWidth:2 });

  // Trails
  let trail1=[], trail2=[];
  const maxTrail=25;

  s.on('drag', ()=>{
    const y0 = s.Value();
    const xA = branch * Math.sqrt(y0);
    const xB = 4 + branch * Math.sqrt(y0);

    const m1 = df1(xA);
    const m2 = df2(xB);
    const b1 = y0 - m1 * xA;
    const b2 = y0 - m2 * xB;

    const t1 = brd.create('functiongraph',[x=>m1*x+b1,-6,10],
      {strokeColor:'#1CA9C9',strokeWidth:1,opacity:0.25,fixed:true});
    trail1.push(t1);
    if(trail1.length>maxTrail) brd.removeObject(trail1.shift());

    const t2 = brd.create('functiongraph',[x=>m2*x+b2,-6,10],
      {strokeColor:'#7FD16C',strokeWidth:1,opacity:0.25,fixed:true});
    trail2.push(t2);
    if(trail2.length>maxTrail) brd.removeObject(trail2.shift());

    brd.update();
  });

  // Labels
  brd.create('text', [-5.5, 16, 'Blue: f‚ÇÅ(x)=x¬≤'], {fontSize:15, color:'#0047AB'});
  brd.create('text', [-5.5, 15, 'Green: f‚ÇÇ(x)=(x‚àí4)¬≤'], {fontSize:15, color:'#178F3E'});
  brd.create('text', [-5.5, 14, 'Tangents remain parallel at equal heights'], {fontSize:14, color:'#333'});
})();
</script>
 Fortunately, there is a closely related quantity that is able to capture the <strong><span style="color: red">uniqueness</span></strong> of each of these functions and that is the \(y\) intercepts of the tangent line which we can see actually do differ depending on the original function. So, taking that into account, we can solve this problem.</p>
<p>Let&#39;s say \((x,y)=(x,f)\) is a point on the parabola &#40;\(y=f(x)=x^2\)&#41;. Then, as mentioned slope is \(df/dx = p\) and the <strong><span style="color: red">\(y\) intercept is g</span></strong>. This \(g\) can be given by,</p>
\[
p = \frac{f + g}{x - 0} \implies g = px - f
\]
<p>This truely captures all the information of the function. 
  <fieldset class=" note"><legend class=" note-legend"> üìù Note</legend>
      Here as the intercept is always negative, I have already taken the intercept to be \((0,-g)\). So, above \(g\) is the distance from origin to intercept. 
  </fieldset>
  </p>
<h2 id="legendre_transformation"><a href="#legendre_transformation" class="header-anchor">Legendre Transformation</a></h2>
<h3 id="introduction__2"><a href="#introduction__2" class="header-anchor">Introduction</a></h3>
<p>Finally, in general if we have a function \(f(x)\), then <strong><span style="color: purple">Legendre Transformation</span></strong> of it is,</p>
\[
g(p) = p\cdot x(p) - f(x(p))
\]
<p>i.e., a transformation which converts one function into another such that the information remains same and whose parameter is slope of the previous one.</p>
<p>For our two functions \(f_1(x) = x^2\) and \(f_2(x) = (x-d)^2\). We get,</p>
\[
g_1(p) = \frac{p}{4} \text{ \ \ and\ \  } g_2(p) = \frac{p^2}{4} + pd
\]
<p>We have now included information of \(y\) intercept too, so each of the original functions of \(x\) maps to a unique function of \(p\). Also, beacuse no information has been lost in this, we can also find the Legendre transform of \(g\) and get back original functions \(f\)&#39;s. 
  <fieldset class=" todo"><legend class=" todo-legend"> ü§î Problem</legend>
      Try showing that if we start from \(g_1\) and \(g_2\), we can recover the original functions \(g_1\) and \(g_2\). 
  </fieldset>
   We now truly have two ways of expressing the same information. One that depends on \(x\) and other on \(p\), providing <strong><span style="color: purple">a beautiful duality between points and lines</span></strong>. This mapping is 1-to-1, i.e., unique.</p>
<h3 id="what_functions_respect_legendre_transformation"><a href="#what_functions_respect_legendre_transformation" class="header-anchor">What functions respect legendre transformation?</a></h3>
<p>Now the question is <strong><span style="color: green">does it works for all functions</span></strong>?, sadly the answer is no&#33;</p>
<p>To motivate the answer let&#39;s start with the function \(f(x) = x^3\). We do the exact same things, we have done before,</p>
\[
f(x) = x^3 \implies f'(x) = 3x^2 = p(x) \implies x = \pm \Big(\frac{p}{3}\Big)^{1/2}
\]
<p>Immediately we run into a problem. This is not a function &#40;not bijective&#41;. Any value we put for \(p\) will gives us two different values of \(x\). This means, there are many airs of points that have same slope. We can see it in the interactive plot below. With the exception of the origin&#40;not Gojo Saturo&#41;, we are always able to find two points that have exact same value. In terms of \(f(x)\), these values correspond to producing the exact same slope for tangent lines. 
<div id="equalSlopeBoard" class="jxgbox"
     style="width:650px;height:500px;margin:auto;border:2px solid #aaa;"></div>

<script>
(function() {
  const brd = JXG.JSXGraph.initBoard('equalSlopeBoard', {
    boundingbox: [-4, 12, 4, -8],
    axis: true,
    showNavigation: false,
    showCopyright: false
  });

  // Define f(x)=x^3 and derivative p(x)=3x^2
  const f = x => x*x*x;
  const df = x => 3*x*x;

  // Plot f(x)
  brd.create('functiongraph', [f, -3, 3],
    {strokeColor:'#0047AB', strokeWidth:2});

  // Plot derivative curve p(x)=3x^2
  brd.create('functiongraph', [df, -3, 3],
    {strokeColor:'#E75480', strokeWidth:2, dash:1});

  // Slider for slope p = 3x^2
  const s = brd.create('slider', [[-3.5,10],[3,10],[0,3,9]],
    {name:'p (slope)', snapWidth:0.1});

  // Compute x-values corresponding to slope p = 3x^2
  function xFromSlope(p) {
    return Math.sqrt(p/3);
  }

  // Points where slope is same (x and -x)
  const P1 = brd.create('point', [
    ()=>xFromSlope(s.Value()),
    ()=>f(xFromSlope(s.Value()))
  ], {name:'x‚ÇÅ',color:'#D13F32',size:3,fixed:true});

  const P2 = brd.create('point', [
    ()=>-xFromSlope(s.Value()),
    ()=>f(-xFromSlope(s.Value()))
  ], {name:'x‚ÇÇ',color:'#D13F32',size:3,fixed:true});

  // Tangents at both points
  const T1 = brd.create('line', [
    ()=>[xFromSlope(s.Value()), f(xFromSlope(s.Value()))],
    ()=>[xFromSlope(s.Value())+1,
         f(xFromSlope(s.Value())) + s.Value()]
  ], {strokeColor:'#1CA9C9', strokeWidth:2, dash:0});

  const T2 = brd.create('line', [
    ()=>[-xFromSlope(s.Value()), f(-xFromSlope(s.Value()))],
    ()=>[-xFromSlope(s.Value())+1,
         f(-xFromSlope(s.Value())) + s.Value()]
  ], {strokeColor:'#1CA9C9', strokeWidth:2, dash:0});

  // Visual guide lines linking to derivative
  const guide1 = brd.create('segment', [
    ()=>[xFromSlope(s.Value()), 0],
    ()=>[xFromSlope(s.Value()), s.Value()]
  ], {strokeColor:'#33B8A0', strokeWidth:1, dash:2});

  const guide2 = brd.create('segment', [
    ()=>[-xFromSlope(s.Value()), 0],
    ()=>[-xFromSlope(s.Value()), s.Value()]
  ], {strokeColor:'#33B8A0', strokeWidth:1, dash:2});

  // Trail memory (faint tangent history)
  let trails = [];
  const maxTrail = 15;

  s.on('drag', ()=>{
    const p = s.Value();
    const xA = xFromSlope(p);
    const xB = -xA;
    const yA = f(xA), yB = f(xB);

    const t1 = brd.create('functiongraph',[x=>p*(x-xA)+yA,-4,4],
      {strokeColor:'#1CA9C9',strokeWidth:1,opacity:0.25,fixed:true});
    const t2 = brd.create('functiongraph',[x=>p*(x-xB)+yB,-4,4],
      {strokeColor:'#1CA9C9',strokeWidth:1,opacity:0.25,fixed:true});

    trails.push(t1,t2);
    if(trails.length>maxTrail*2) {
      brd.removeObject(trails.shift());
      brd.removeObject(trails.shift());
    }
    brd.update();
  });

  // Labels
  brd.create('text', [-3.8,9.2,'f(x)=x¬≥ (blue),  p(x)=3x¬≤ (pink)'], {fontSize:14});
  brd.create('text', [-3.8,8.3,'Two tangents share the same slope p'], {fontSize:14});
})();
</script>
 This gives us the key thing we need in order to be able to find the <strong>legendre transform</strong> of a given function. <strong><span style="color: red">We need all the slopes of tangent lines to be unique</span></strong> and this will happen if the <strong><span style="color: red">function&#39;s derivative is always increasing or decreasing, i.e., monotonically increasing or decreasing</span></strong>. From \(f\)&#39;s point of view, for <strong>f</strong> to have legendre transformation, <strong><span style="color: red">f&#40;x&#41; must be convex</span></strong>, means if we connect any two points on the curve, the line is always on the same side of the curve. To check if any function is <strong><span style="color: red">convex</span></strong>, we can just find it&#39;s second derivative and then if,</p>
\[
f''(x)\geq 0 \text{ \ \ \ \ \ for all } x \text{ \ in the domain}
\]
<p>then \(f(x)\) is convex. With all of these, we now know what is <strong>Legendre Transform</strong> and on which functions we can apply it on.</p>
<p>But does it only works on single variable functions?, Well no&#33;, we can apply the idea on multivariable functions too&#33; and also there can be some variables which don&#39;t participate in the transformation. Let&#39;s see this:</p>
<h3 id="legendre_transform_of_multi-variable_functions"><a href="#legendre_transform_of_multi-variable_functions" class="header-anchor">Legendre Transform of multi-variable functions</a></h3>
<p>Suppose we have a function \(f(x_1,x_2,\cdots, x_n, u_1,u_2,\cdots,u_m)\) then let&#39;s say we want to create a function for studying the same system but with \(p_1,p_2,p_3,\cdots , p_n\) where \(p_i = \partial f/\partial x_i\) and keep \(u_i\)&#39;s as they are. Then, the Legendre Transform is,</p>
\[
g(p_1,p_2,\cdots,p_m,u_1,u_2,\cdots,u_m) = \sum_{i=1}^{n} p_i x_i - f(x_1(p_1),x_2(p_2),\cdots, x_n(p_n),u_1,u_2,\cdots,u_m)
\]
<p>We can easily show that \(g\) will only be function of \(p\)&#39;s and \(u\)&#39;s only. 
  <fieldset class=" note"><legend class=" note-legend"> üìù Note</legend>
      Visit this <a href="https://notes.myscript.com/page/86a4f8eb-d648-4f77-8cce-0641d6ec619e">page</a> for the proof. <br/>Here for multivariable case, we check the Hessian Matrix &#40;positive semi-definite then convex&#41; for convex check. 
  </fieldset>
  </p>
<h2 id="application_of_legendre_transform"><a href="#application_of_legendre_transform" class="header-anchor">Application of Legendre Transform</a></h2>
<p>There are many applications of this transformation. But the most iconic ones are in <strong>Classical Mechanics</strong> and <strong>Thermodynamics</strong>. As thermodyanics one is much more popular, we will see that one here.</p>
<p>As we know internal energy&#40;\(U\)&#41; of s system is a function of state which means that a system undergoes the same change in \(U\) when we move it from one equilibrium state to another, irrespetive of which route we take through parameter space. This makes \(U\) a very useful quantity. But we know \(U = U(V,S)\), i.e., it&#39;s function of <strong>entropy</strong> and <strong>volume</strong>&#40;keeping particle number constant&#41;.</p>
<p>But to be honest \(S\) is very hard to control. Rather controlling \(T\) and \(p\) is much more easy. But then what we do?</p>
<p>To truly undertsand it let&#39;s start with \(U\). From 1st law of thermodynamics,</p>
\[
dU = \Bigg(\frac{\partial U}{\partial S}\Bigg)_V dS+ \Bigg(\frac{\partial U}{\partial V}\Bigg)_S dV = T\ dS - p\ dV
\]
<p>This gives us,</p>
\[
T = \Bigg(\frac{\partial U}{\partial S}\Bigg)_V \text{\ \ \ and \ \ \ } p = -\Bigg(\frac{\partial U}{\partial S}\Bigg)_S
\]
<p>So, for constant volume process of our system, \(dU = T\ dS\) and much more.<br/></p>
<p>But now we want to study a system where the temperature is constant. How are we going to study such systems?.. How are we going to study the energy change?</p>
<p>The answer just find a function which is also energy but one of it&#39;s parameters are \(T\). As we know \(S\) and \(T\) are related and as we just showed they are related by derivative&#40;like \(p\) and \(x\) in previous examples&#41;. This should shout the name of our legendary <strong>Legendre Transformation</strong>.</p>
<p>So, we will define,</p>
\[
F = U - TS
\]
<p>&#40;We can also use \(TS-U\) but then the physical interpretations will not be straight-forward, so we use this convention of using \(U-TS\)&#41;. This then tells us,</p>
\[
dF = T\ dS - p\ dV - T\ dS - S\ dT = -S\ dT - p\ dV
\]
<p>This implies that the natural variables for \(F\) are \(V\) and \(T\), i.e., \(F=F(V,T)\). Then for a Isothermal process, we have,</p>
\[
dF = -p\ dV \implies \Delta F = -\int_{V_1}^{V_2}p\ dV
\]
<p>Hence, a positive change in \(F\) represents reversible work done on the system by the surroundings, while a negative change in \(F\) means reversible work done on the surrounding by the system.</p>
<p>We can also see as \(dF = dU - T\ dS\) &#40;for constant \(T\)&#41; and \(dW\geq dU - T\ dS\) &#40;equality holds for reversible process&#41;. So, we have,</p>
\[
dW\geq dF
\]
<p>What it means is, adding work to the system increases the system&#39;s F&#40;called Helmholtz energy&#41;. In a reversible process, \(dW = dF\) and the work added to the system goes directly into increasing the Helmholtz energy. If we extract a certain amount of work from system&#40;\(dW<0\)&#41;, then this will be associated with at least as big a drop in the system&#39;s \(F\).</p>
<p>This shows how powerful Legendre Transformation is. Using it we just found something \(F\) which is also energy&#40;check the dimension&#41; and not just any energy, It represent a very powerful energy, i.e., free energy. This tells us <strong><span style="color: purple">how much energy we can extract from the system, i.e., how much energy is avaliable for us to extract from the system</span></strong>.</p>
<p>In this way, we can find many more useful things. Maybe in another blog I will discuss them. 
  <fieldset class=" todo"><legend class=" todo-legend"> ü§î Problem</legend>
      Suppose, we want to study our system under isobaric process &#40;\(P=\) constant&#41;. Try creating a new type of energy for that from \(U(S,V)\).</p>
<p>Also, try finding what will be it&#39;s physical interpretation.</p>
<p>
  </fieldset>
  </p>
<p>If you guys are interested read:</p>
<ol>
<li><p>A Student&#39;s Guide to Entropy by Lemons</p>
</li>
<li><p>An Introductory Course of Statistical Mechanics by P.B. Pal</p>
</li>
<li><p><a href="https://arxiv.org/pdf/0806.1147">Making sense of the Legendre transform</a>. American Journal of Physics. 77 &#40;7&#41;: 614, Zia, R. K. P.; Redish, E. F.; McKay, S. R. &#40;2009&#41;</p>
</li>
</ol>
<p>I have mainly followed 3rd one along with 2nd one.</p>
<hr />
<p>I hope you learn something new and enjoyed this article.</p>
<p>If you have some queries, do let me know in the comments or contact me using my using the informations that are given on the page <a href="/Pages/about_me/">About Me</a>.</p>

<button onclick="window.history.back()">Go Back</button>


<div id="disqus_thread"></div>
<script>
    /**
    *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
    *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables    */
    /*
    var disqus_config = function () {
    this.page.url = https://rousan.netlify.app/pages/physics/blogs/legendre_trans/;  // Replace PAGE_URL with your page's canonical URL variable
    this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */
    (function() { // DON'T EDIT BELOW THIS LINE
    var d = document, s = d.createElement('script');
    s.src = 'https://https-rousan-netlify-app.disqus.com/embed.js';
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<div class="page-foot">
    <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Kazi Abu Rousan. Last modified: October 31, 2025.
    Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
</div>



<!-- Collapsible button example -->
<script>
    var coll = document.getElementsByClassName("collapsible");
    var i;
    
    for (i = 0; i < coll.length; i++) {
      coll[i].addEventListener("click", function() {
        this.classList.toggle("active");
        var content = this.nextElementSibling;
        if (content.style.display === "block") {
          content.style.display = "none";
        } else {
          content.style.display = "block";
        }
      });
    }
  </script>
  <!-- End collapsible button example --></div><!-- CONTENT ENDS HERE -->

      </div> <!-- closure of main -->
    </div>   <!-- closure of class initial--content -->

    <div class="page__footer">
      <footer>
        <!-- start custom footer snippets -->
        <!-- end custom footer snippets -->
        <div class="page__footer-follow">
          <ul class="social-icons">
            <li><strong>Follow:</strong></li>
            <li><a href="https://twitter.com/AustinRousan" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-twitter-square" aria-hidden="true"></i> Twitter</a></li>
            <li><a href="https://github.com/aburousan" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
            <li><a href="https://www.linkedin.com/in/kazi-abu-rousan-819848198/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
            <li><a href="https://www.instagram.com/azavzya/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-instagram" aria-hidden="true"></i> Instagram</a></li>


          </ul>
        </div>
        <div class="page__footer-copyright">&copy; Kazi Abu Rousan. Powered by <a href="https://github.com/tlienart/Franklin.jl">Franklin</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>
      </footer>
    </div>

    <script src="/libs/minimal-mistakes/main.min.js"></script>
    <script defer src="https://use.fontawesome.com/releases/v5.8.2/js/all.js" integrity="sha384-DJ25uNYET2XCl5ZF++U8eNxPWqcKohUUBUpKGlNLMchM7q4Wjg2CUpjHLaL8yYPH" crossorigin="anonymous"></script>

    
        <script src="/libs/katex/katex.min.js"></script>
<script src="/libs/katex/contrib/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/libs/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();hljs.configure({tabReplace: '    '});</script>

    
  </body>
</html>


<script>
  (function(){
  
    // Get the elements.
    // - the 'pre' element.
    // - the 'div' with the 'paste-content' id.
  
    var pre = document.getElementsByTagName('pre');
  
    // Add a copy button in the 'pre' element.
    // which only has the className of 'language-' or ' hljs'(if enable highlight.js pre-render).
  
    for (var i = 0; i < pre.length; i++) {
      var tag_name = pre[i].children[0].className
                var isLanguage = tag_name.startsWith('language-') || tag_name.endsWith(' hljs');
      if ( isLanguage ) {
        var button           = document.createElement('button');
            button.className = 'copy-button';
            button.textContent = 'Copy';
  
            pre[i].appendChild(button);
      }
    };
  
    // Run Clipboard
  
    var copyCode = new Clipboard('.copy-button', {
      target: function(trigger) {
        return trigger.previousElementSibling;
      }
    });
  
    // On success:
    // - Change the "Copy" text to "Copied".
    // - Swap it to "Copy" in 2s.
    // - Lead user to the "contenteditable" area with Velocity scroll.
  
    copyCode.on('success', function(event) {
      event.clearSelection();
      event.trigger.textContent = 'Copied';
      window.setTimeout(function() {
        event.trigger.textContent = 'Copy';
      }, 2000);
  
    });
  
    // On error (Safari):
    // - Change the  "Press Ctrl+C to copy"
    // - Swap it to "Copy" in 2s.
  
    copyCode.on('error', function(event) {
      event.trigger.textContent = 'Press "Ctrl + C" to copy';
      window.setTimeout(function() {
        event.trigger.textContent = 'Copy';
      }, 5000);
    });
  
  })();
  </script>